// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shelter.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Shelter _$ShelterFromJson(Map<String, dynamic> json) {
  return _Shelter.fromJson(json);
}

/// @nodoc
mixin _$Shelter {
  String get r_area_nm => throw _privateConstructorUsedError;
  String get r_detl_add => throw _privateConstructorUsedError;
  num get lo => throw _privateConstructorUsedError;
  num get la => throw _privateConstructorUsedError;
  num get use_prnb => throw _privateConstructorUsedError;
  num get cler2_cnt => throw _privateConstructorUsedError;
  num get cler1_cnt => throw _privateConstructorUsedError;
  dynamic get required => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ShelterCopyWith<Shelter> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShelterCopyWith<$Res> {
  factory $ShelterCopyWith(Shelter value, $Res Function(Shelter) then) =
      _$ShelterCopyWithImpl<$Res, Shelter>;
  @useResult
  $Res call(
      {String r_area_nm,
      String r_detl_add,
      num lo,
      num la,
      num use_prnb,
      num cler2_cnt,
      num cler1_cnt,
      dynamic required});
}

/// @nodoc
class _$ShelterCopyWithImpl<$Res, $Val extends Shelter>
    implements $ShelterCopyWith<$Res> {
  _$ShelterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? r_area_nm = null,
    Object? r_detl_add = null,
    Object? lo = null,
    Object? la = null,
    Object? use_prnb = null,
    Object? cler2_cnt = null,
    Object? cler1_cnt = null,
    Object? required = freezed,
  }) {
    return _then(_value.copyWith(
      r_area_nm: null == r_area_nm
          ? _value.r_area_nm
          : r_area_nm // ignore: cast_nullable_to_non_nullable
              as String,
      r_detl_add: null == r_detl_add
          ? _value.r_detl_add
          : r_detl_add // ignore: cast_nullable_to_non_nullable
              as String,
      lo: null == lo
          ? _value.lo
          : lo // ignore: cast_nullable_to_non_nullable
              as num,
      la: null == la
          ? _value.la
          : la // ignore: cast_nullable_to_non_nullable
              as num,
      use_prnb: null == use_prnb
          ? _value.use_prnb
          : use_prnb // ignore: cast_nullable_to_non_nullable
              as num,
      cler2_cnt: null == cler2_cnt
          ? _value.cler2_cnt
          : cler2_cnt // ignore: cast_nullable_to_non_nullable
              as num,
      cler1_cnt: null == cler1_cnt
          ? _value.cler1_cnt
          : cler1_cnt // ignore: cast_nullable_to_non_nullable
              as num,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ShelterCopyWith<$Res> implements $ShelterCopyWith<$Res> {
  factory _$$_ShelterCopyWith(
          _$_Shelter value, $Res Function(_$_Shelter) then) =
      __$$_ShelterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String r_area_nm,
      String r_detl_add,
      num lo,
      num la,
      num use_prnb,
      num cler2_cnt,
      num cler1_cnt,
      dynamic required});
}

/// @nodoc
class __$$_ShelterCopyWithImpl<$Res>
    extends _$ShelterCopyWithImpl<$Res, _$_Shelter>
    implements _$$_ShelterCopyWith<$Res> {
  __$$_ShelterCopyWithImpl(_$_Shelter _value, $Res Function(_$_Shelter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? r_area_nm = null,
    Object? r_detl_add = null,
    Object? lo = null,
    Object? la = null,
    Object? use_prnb = null,
    Object? cler2_cnt = null,
    Object? cler1_cnt = null,
    Object? required = freezed,
  }) {
    return _then(_$_Shelter(
      r_area_nm: null == r_area_nm
          ? _value.r_area_nm
          : r_area_nm // ignore: cast_nullable_to_non_nullable
              as String,
      r_detl_add: null == r_detl_add
          ? _value.r_detl_add
          : r_detl_add // ignore: cast_nullable_to_non_nullable
              as String,
      lo: null == lo
          ? _value.lo
          : lo // ignore: cast_nullable_to_non_nullable
              as num,
      la: null == la
          ? _value.la
          : la // ignore: cast_nullable_to_non_nullable
              as num,
      use_prnb: null == use_prnb
          ? _value.use_prnb
          : use_prnb // ignore: cast_nullable_to_non_nullable
              as num,
      cler2_cnt: null == cler2_cnt
          ? _value.cler2_cnt
          : cler2_cnt // ignore: cast_nullable_to_non_nullable
              as num,
      cler1_cnt: null == cler1_cnt
          ? _value.cler1_cnt
          : cler1_cnt // ignore: cast_nullable_to_non_nullable
              as num,
      required: freezed == required ? _value.required! : required,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Shelter with DiagnosticableTreeMixin implements _Shelter {
  const _$_Shelter(
      {required this.r_area_nm,
      required this.r_detl_add,
      required this.lo,
      required this.la,
      required this.use_prnb,
      required this.cler2_cnt,
      required this.cler1_cnt,
      this.required});

  factory _$_Shelter.fromJson(Map<String, dynamic> json) =>
      _$$_ShelterFromJson(json);

  @override
  final String r_area_nm;
  @override
  final String r_detl_add;
  @override
  final num lo;
  @override
  final num la;
  @override
  final num use_prnb;
  @override
  final num cler2_cnt;
  @override
  final num cler1_cnt;
  @override
  final dynamic required;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Shelter(r_area_nm: $r_area_nm, r_detl_add: $r_detl_add, lo: $lo, la: $la, use_prnb: $use_prnb, cler2_cnt: $cler2_cnt, cler1_cnt: $cler1_cnt, required: $required)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Shelter'))
      ..add(DiagnosticsProperty('r_area_nm', r_area_nm))
      ..add(DiagnosticsProperty('r_detl_add', r_detl_add))
      ..add(DiagnosticsProperty('lo', lo))
      ..add(DiagnosticsProperty('la', la))
      ..add(DiagnosticsProperty('use_prnb', use_prnb))
      ..add(DiagnosticsProperty('cler2_cnt', cler2_cnt))
      ..add(DiagnosticsProperty('cler1_cnt', cler1_cnt))
      ..add(DiagnosticsProperty('required', required));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Shelter &&
            (identical(other.r_area_nm, r_area_nm) ||
                other.r_area_nm == r_area_nm) &&
            (identical(other.r_detl_add, r_detl_add) ||
                other.r_detl_add == r_detl_add) &&
            (identical(other.lo, lo) || other.lo == lo) &&
            (identical(other.la, la) || other.la == la) &&
            (identical(other.use_prnb, use_prnb) ||
                other.use_prnb == use_prnb) &&
            (identical(other.cler2_cnt, cler2_cnt) ||
                other.cler2_cnt == cler2_cnt) &&
            (identical(other.cler1_cnt, cler1_cnt) ||
                other.cler1_cnt == cler1_cnt) &&
            const DeepCollectionEquality().equals(other.required, required));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      r_area_nm,
      r_detl_add,
      lo,
      la,
      use_prnb,
      cler2_cnt,
      cler1_cnt,
      const DeepCollectionEquality().hash(required));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ShelterCopyWith<_$_Shelter> get copyWith =>
      __$$_ShelterCopyWithImpl<_$_Shelter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ShelterToJson(
      this,
    );
  }
}

abstract class _Shelter implements Shelter {
  const factory _Shelter(
      {required final String r_area_nm,
      required final String r_detl_add,
      required final num lo,
      required final num la,
      required final num use_prnb,
      required final num cler2_cnt,
      required final num cler1_cnt,
      final dynamic required}) = _$_Shelter;

  factory _Shelter.fromJson(Map<String, dynamic> json) = _$_Shelter.fromJson;

  @override
  String get r_area_nm;
  @override
  String get r_detl_add;
  @override
  num get lo;
  @override
  num get la;
  @override
  num get use_prnb;
  @override
  num get cler2_cnt;
  @override
  num get cler1_cnt;
  @override
  dynamic get required;
  @override
  @JsonKey(ignore: true)
  _$$_ShelterCopyWith<_$_Shelter> get copyWith =>
      throw _privateConstructorUsedError;
}
